import groovy.json.JsonBuilder
import groovy.json.JsonSlurper

apply plugin: 'maven-publish'
apply plugin: 'signing'

def repoOwner = project.hasProperty('repoOwner') ? project.repoOwner : ''
def repoName = project.hasProperty('repoName') ? project.repoName : ''
def ossrhUsername = project.hasProperty('ossrhUsername') ? project.ossrhUsername : ''
def ossrhPassword = project.hasProperty('ossrhPassword') ? project.ossrhPassword : ''
def ossrhToken = project.hasProperty('ossrhToken') ? project.ossrhToken : ''
def ossrhNamespace = "com.pushwoosh"
def ossrhPostUrl = "https://ossrh-staging-api.central.sonatype.com/manual/upload/defaultRepository/${ossrhNamespace}"
def centralPublisherApiUrl = "https://central.sonatype.com/api/v1/publisher/deployment"

def LIB_GROUP_ID = global_targetGroupId
def LIB_ARTIFACT_ID = targetArtefactId
def LIB_VERSION = global_versionName
def POM_NAME = targetName
def POM_DESCRIPTION = targetDescription
def REPOSITORY_URL = 'https://ossrh-staging-api.central.sonatype.com/service/local/staging/deploy/maven2/'
def SNAPSHOT_URL = 'https://ossrh-staging-api.central.sonatype.com/content/repositories/snapshots'
def POM_URL = "https://github.com:${repoOwner}/${repoName}"
def SCM_CONNECTION = "scm:git:git@github.com:${repoOwner}/${repoName}.git"
def SCM_DEVELOPER_CONNECTION = "scm:git:git@github.com:${repoOwner}/${repoName}.git"
def SCM_URL = "git@github.com:${repoOwner}/${repoName}.git"

def legacySupportV4Version = "1.0.0"
def androidAnnotationVersion = "[1.0.0, 1.3.99]"
def androidAppCompatVersion = "[1.0.0, 1.6.99]"
def androidRecyclerViewVersion = "[1.0.0, 1.2.99]"
def androidMaterialVersion = "[1.0.0, 1.12.99]"
def constraintLayoutVersion = "(1.0.1, 1.1.99]"
def playServicesVersion = "[21.0.1, 21.0.99]"
def glideVersion = "[4.4.0, 4.11.0]"
def pushwooshVersion = global_versionName
def workManagerVersion = "[2.0.0, 2.8.99]"
def swipeRefreshLayoutVersion = "[1.0.0, 1.1.99]"
def coreKtxVersion = "1.10.1"

def addDependency(node, groupId, artifactId, version, type = 'aar', scope = 'compile') {
    node.appendNode('dependency').with {
        appendNode('groupId', groupId)
        appendNode('artifactId', artifactId)
        appendNode('version', version)
        appendNode('type', type)
        appendNode('scope', scope)
    }
}

afterEvaluate {
    publishing {
        repositories {
            maven {
                name = 'ossrh-staging-api'
                url = pushwooshVersion.endsWith('SNAPSHOT') ? SNAPSHOT_URL : REPOSITORY_URL
                credentials {
                    username = ossrhUsername
                    password = ossrhPassword
                }
            }
        }
        publications {
            release(MavenPublication) {
                from components.release
                artifactId = LIB_ARTIFACT_ID
                groupId = "com.pushwoosh"
                version = LIB_VERSION

                // Add custom javadoc JAR (if task exists)
                def customJavadocJarTask = tasks.findByName('customJavadocJarRelease')
                if (customJavadocJarTask != null) {
                    artifact customJavadocJarTask
                }

                pom {
                    name = POM_NAME
                    description = POM_DESCRIPTION
                    url = POM_URL
                    packaging = 'aar'

                    licenses {
                        license {
                            name = 'Pushwoosh License'
                            url = 'https://github.com/Pushwoosh/pushwoosh-android-sdk/blob/master/LICENSE'
                        }
                    }
                    developers {
                        developer {
                            id = 'vromanychev'
                            name = 'Vitaly Romanychev'
                            email = 'vromanychev@pushwoosh.com'
                            organization = 'Pushwoosh'
                            organizationUrl = 'http://www.pushwoosh.com/'
                        }
                    }
                    scm {
                        connection = SCM_CONNECTION
                        developerConnection = SCM_DEVELOPER_CONNECTION
                        url = SCM_URL
                    }

                    withXml {
                        asNode().dependencies.'*'.findAll {
                            it.artifactId.text().contains('pushwoosh')
                        }.each {
                            it.groupId*.value = LIB_GROUP_ID
                            it.version*.value = LIB_VERSION
                        }

                        asNode().appendNode('build')
                                .appendNode('plugins')
                                .with {
                                    appendNode('plugin')
                                            .with {
                                                appendNode('groupId', 'org.sonatype.plugins')
                                                appendNode('artifactId', 'nexus-staging-maven-plugin')
                                                appendNode('version', '1.6.13')
                                                appendNode('extensions', 'true')
                                                appendNode('configuration').with {
                                                    appendNode('serverId', 'ossrh')
                                                    appendNode('nexusUrl', 'https://oss.sonatype.org/')
                                                    appendNode('autoReleaseAfterClose', 'false')
                                                }
                                            }
                                    appendNode('plugin')
                                            .with {
                                                appendNode('groupId', 'com.simpligility.maven.plugins')
                                                appendNode('artifactId', 'android-maven-plugin')
                                                appendNode('version', '4.1.0')
                                                appendNode('extensions', 'true')
                                                appendNode('configuration').with {
                                                    appendNode('sign').with {
                                                        appendNode('debug', 'false')
                                                    }
                                                }
                                            }
                                }

                        // Find existing dependencies node (created by 'from components.release') or create new one
                        def dependenciesNode = asNode().dependencies[0] ?: asNode().appendNode('dependencies')
                        switch (project.name) {
                            case 'pushwoosh':
                                addDependency(dependenciesNode, 'androidx.legacy', 'legacy-support-v4', legacySupportV4Version)
                                addDependency(dependenciesNode, 'androidx.work', 'work-runtime', workManagerVersion)
                                break
                            case 'pushwoosh-amazon':
                                addDependency(dependenciesNode, 'androidx.annotation', 'annotation', androidAnnotationVersion, 'jar')
                                addDependency(dependenciesNode, 'com.pushwoosh', 'pushwoosh', pushwooshVersion)
                                break
                            case 'pushwoosh-location':
                                addDependency(dependenciesNode, 'androidx.legacy', 'legacy-support-v4', legacySupportV4Version)
                                addDependency(dependenciesNode, 'com.google.android.gms', 'play-services-location', playServicesVersion)
                                addDependency(dependenciesNode, 'com.pushwoosh', 'pushwoosh', pushwooshVersion)
                                break
                            case 'pushwoosh-inbox':
                                addDependency(dependenciesNode, 'androidx.annotation', 'annotation', androidAnnotationVersion, 'jar')
                                addDependency(dependenciesNode, 'com.pushwoosh', 'pushwoosh', pushwooshVersion)
                                break
                            case 'pushwoosh-inbox-ui':
                                addDependency(dependenciesNode, 'androidx.appcompat', 'appcompat', androidAppCompatVersion)
                                addDependency(dependenciesNode, 'androidx.recyclerview', 'recyclerview', androidRecyclerViewVersion)
                                addDependency(dependenciesNode, 'com.google.android.material', 'material', androidMaterialVersion)
                                addDependency(dependenciesNode, 'androidx.constraintlayout', 'constraintlayout', constraintLayoutVersion)
                                addDependency(dependenciesNode, 'androidx.swiperefreshlayout', 'swiperefreshlayout', swipeRefreshLayoutVersion)
                                addDependency(dependenciesNode, 'com.github.bumptech.glide', 'glide', glideVersion)
                                addDependency(dependenciesNode, 'com.pushwoosh', 'pushwoosh-inbox', pushwooshVersion)
                                break
                            case 'pushwoosh-calls':
                                addDependency(dependenciesNode, 'androidx.appcompat', 'appcompat', androidAppCompatVersion)
                                addDependency(dependenciesNode, 'androidx.core', 'core-ktx', coreKtxVersion)
                                addDependency(dependenciesNode, 'com.google.android.material', 'material', androidMaterialVersion)
                                addDependency(dependenciesNode, 'com.pushwoosh', 'pushwoosh', pushwooshVersion)
                                break
                            default:
                                addDependency(dependenciesNode, 'com.pushwoosh', 'pushwoosh', pushwooshVersion)
                        }
                    }
                }
            }
        }
    }
}
signing {
    // Skip signing ONLY if explicitly requested (useful for local testing)
    // Usage: ./gradlew publishToMavenLocal -Psigning.skip=true
    // Otherwise signing is REQUIRED (will fail if credentials missing)
    required { !project.hasProperty('signing.skip') }
    sign publishing.publications
}

/*
*  helper function, creates an authorized HttpUrlConnection with a given URL and METHOD,
*  adds optional payload to PUT and POST requests
*/
def httpRequest(String method, String url, String token, String body = null) {
    def connection = new URL(url).openConnection() as HttpURLConnection
    connection.setRequestMethod(method)
    connection.setRequestProperty("Authorization", "Bearer $token")

    if (method in ["POST", "PUT"]) {
        connection.setRequestProperty("Content-Type", "application/json")
        connection.setDoOutput(true)
        if (body) {
            connection.outputStream.withWriter("UTF-8") { it << body }
        }
    } else if (method in ["GET", "DELETE"]) {
        connection.setRequestProperty("Accept", "application/json")
    }

    return connection
}

// helper function that obtains a list of all active deployments in maven central
def fetchOssrhDeployments(String token) {
    def connection = httpRequest(
            "GET",
            "https://ossrh-staging-api.central.sonatype.com/manual/search/repositories",
            token
    )

    int responseCode = connection.responseCode
    if (responseCode < 200 || responseCode >= 300) {
        def errorText = connection.errorStream?.text
        throw new GradleException("Failed to fetch deployments: $errorText")
    }

    def parsed = new JsonSlurper().parseText(connection.inputStream.text)
    return parsed.repositories
}

// OSSRH API used to make publications in OSSRH Staging visible in Maven Central
if (!rootProject.tasks.findByName("notifyOssrhUpload")) {
    rootProject.tasks.register("notifyOssrhUpload") {
        group = "publishing"
        description = "Notify OSSRH after all modules are published"

        doLast {
            println "Notifying OSSRH upload for namespace: $ossrhNamespace"

            def payload = new JsonBuilder([
                    publishing_type: "portal_api"
            ]).toString()

            def connection = httpRequest("POST", ossrhPostUrl, ossrhToken, payload)

            int responseCode = connection.responseCode
            println "OSSRH Response Code: $responseCode"
            println "OSSRH Message: ${connection.responseMessage}"

            if (responseCode >= 200 && responseCode < 300) {
                println "Successfully notified OSSRH"
            } else {
                def errorText = connection.errorStream?.text
                println "Failed to notify OSSRH: $errorText"
                throw new GradleException("OSSRH upload notification failed with status $responseCode")
            }
        }
    }
}

// Gets the last uploaded deployment and releases it if there is exactly 1 deployment
if (!rootProject.tasks.findByName("releaseCurrentDeployment")) {
    rootProject.tasks.register("releaseCurrentDeployment") {
        group = "publishing"
        description = "Releases the only deployment in OSSRH if exactly one exists"

        doLast {
            def deployments = fetchOssrhDeployments(ossrhToken)

            if (!deployments || deployments.isEmpty()) {
                throw new GradleException("No deployments found in OSSRH.")
            }

            if (deployments.size() > 1) {
                println "Multiple deployments found (${deployments.size()}):"
                deployments.eachWithIndex { repo, i ->
                    println "  ${i + 1}) ID: ${repo.portal_deployment_id}, Key: ${repo.key}, State: ${repo.state}"
                }
                throw new GradleException("Expected exactly 1 deployment. Found ${deployments.size()}. Aborting release.")
            }

            def deployment = deployments[0]
            def deploymentId = deployment.portal_deployment_id

            println "Found single deployment:"
            println "   ID: ${deploymentId}"
            println "   Key: ${deployment.key}"
            println "   State: ${deployment.state}"

            def releaseUrl = "${centralPublisherApiUrl}/${deploymentId}"
            def connection = httpRequest("POST", releaseUrl, ossrhToken)

            println "Releasing deployment to Central..."
            int responseCode = connection.responseCode

            if (responseCode == 204) {
                println "Deployment released successfully"
            } else {
                def errorText = connection.errorStream?.text
                throw new GradleException("Failed to release deployment: $errorText")
            }
        }
    }
}

//drops all existing deployments, should be run before publishing a new deployment to OSSRH Staging
if (!rootProject.tasks.findByName("dropAllDeployments")) {
    rootProject.tasks.register("dropAllDeployments") {
        group = "publishing"
        description = "Drops all deployments from Central, regardless of status"

        doLast {
            def deployments = fetchOssrhDeployments(ossrhToken)

            if (!deployments || deployments.isEmpty()) {
                println "No deployments found to drop."
                return
            }

            println "Dropping all ${deployments.size()} deployments..."

            deployments.each { deployment ->
                def id = deployment.portal_deployment_id
                def dropUrl = "${centralPublisherApiUrl}/${id}"
                def connection = httpRequest("DELETE", dropUrl, ossrhToken)

                int responseCode = connection.responseCode
                if (responseCode == 204) {
                    println "Dropped deployment: ${id}"
                } else {
                    def errorText = connection.errorStream?.text
                    println "Failed to drop ${id}: $errorText"
                }
            }
        }
    }
}

// debug task that gets all currently active deployments
if (!rootProject.tasks.findByName("listOssrhRepositories")) {
    rootProject.tasks.register("listOssrhRepositories") {
        group = "publishing"
        description = "Query OSSRH staging repositories for the current namespace"

        doLast {
            def deployments = fetchOssrhDeployments(ossrhToken)

            println "Found ${deployments.size()} repositories:"
            deployments.each { repo ->
                println "   ID: ${repo.portal_deployment_id}"
                println "   Key: ${repo.key}"
                println "   State: ${repo.state}"
                println "   --------------------------------"
            }
        }
    }
}

afterEvaluate {
    def publishTask = tasks.findByName("publishReleasePublicationToOssrh-staging-apiRepository")
    def notifyTask = rootProject.tasks.findByName("notifyOssrhUpload")

    if (publishTask != null && notifyTask != null) {
        notifyTask.mustRunAfter(publishTask)
        publishTask.finalizedBy(notifyTask)
    }
}




