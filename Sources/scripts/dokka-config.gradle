// ============================================
// Dokka Configuration for SDK Modules
// ============================================
// This file contains shared Dokka configuration
// Applied to all SDK modules via: apply from: '../scripts/dokka-config.gradle'

// ============================================
// Configuration Mode Selection
// ============================================

/**
 * Determine which source of public API classes to use:
 * - If -PpublicApiOnly=true: Use tools/public-api.yaml (PUBLIC API ONLY)
 * - Otherwise: Use proguard/public.txt (ALL CLASSES - legacy mode)
 */
def usePublicApiYaml = project.hasProperty('publicApiOnly') &&
        project.property('publicApiOnly').toString().toBoolean()

if (usePublicApiYaml) {
    logger.lifecycle("📗 Documentation mode: PUBLIC API ONLY (from tools/public-api.yaml)")
} else {
    logger.lifecycle("📚 Documentation mode: ALL CLASSES (from ProGuard files)")
}

// ============================================
// ProGuard Parsing Functions
// ============================================

/**
 * Parse single ProGuard class declaration line
 * @param line ProGuard rule line (e.g., "-keep public class com.example.ClassName")
 * @return Class name (e.g., "com.example.ClassName") or null if not a class declaration
 */
def parseProguardClassName(String line) {
    def keepClassPattern = ~/-keep\s+.*?\b(?:class|enum|interface)\s+([\w.$*]+)[\s\{]/
    def matcher = keepClassPattern.matcher(line)
    return matcher.find() ? matcher.group(1) : null
}

/**
 * Resolve source files for wildcard pattern (e.g., com.example.**)
 * @param className Wildcard class pattern (e.g., "com.pushwoosh.inbox.ui.**")
 * @return List of source files matching the pattern
 */
def resolveWildcardPattern(String className) {
    def packagePath = className.replace('.', '/').replace('**', '')
    def packageDir = file("src/main/java/" + packagePath)
    def files = []

    if (packageDir.exists() && packageDir.isDirectory()) {
        packageDir.eachFileRecurse { f ->
            if (f.isFile() && (f.name.endsWith('.java') || f.name.endsWith('.kt'))) {
                files.add(f)
                logger.debug("Found public class from wildcard: ${f.name}")
            }
        }
        logger.debug("Processed wildcard pattern: ${className} (${files.size()} files)")
    } else {
        logger.debug("Wildcard package not found: ${packagePath}")
    }

    return files
}

/**
 * Resolve source file for concrete class name
 * Handles inner classes (ClassName$Builder) and both Java/Kotlin files
 * @param className Fully qualified class name (e.g., "com.pushwoosh.Pushwoosh")
 * @return Source file or null if not found
 */
def resolveClassName(String className) {
    // Handle inner classes: com.pushwoosh.LocalNotification$Builder -> LocalNotification
    def topLevelClass = className.replaceAll(/\$.*$/, '')

    // Convert com.pushwoosh.Pushwoosh -> src/main/java/com/pushwoosh/Pushwoosh
    def baseFilePath = "src/main/java/" + topLevelClass.replace('.', '/')

    // Try both .java and .kt files
    def javaFile = file(baseFilePath + ".java")
    if (javaFile.exists()) {
        logger.debug("Found public class: ${className} -> ${javaFile.name}")
        return javaFile
    }

    def kotlinFile = file(baseFilePath + ".kt")
    if (kotlinFile.exists()) {
        logger.debug("Found public class: ${className} -> ${kotlinFile.name}")
        return kotlinFile
    }

    logger.debug("ProGuard references non-existent file: ${baseFilePath}.{java|kt}")
    return null
}

/**
 * Parse tools/public-api.yaml to get public API classes for current module
 * @return List of class names for this module, or null if not found
 */
def parsePublicApiYaml() {
    // Get YAML path from property (set by bash script) or use default
    def yamlPath = project.findProperty('publicApiYamlPath') ?: "../../tools/public-api.yaml"
    def yamlFile = file(yamlPath)

    if (!yamlFile.exists()) {
        throw new GradleException("❌ Public API YAML not found at ${yamlFile.absolutePath}\n" +
                "Please ensure the file exists or check -PpublicApiYamlPath property")
    }

    def classNames = []
    def inCurrentModule = false
    def moduleName = project.name

    yamlFile.eachLine { line ->
        // Check if we're in the current module section
        if (line.matches(/^\s{2}${moduleName}:\s*$/)) {
            inCurrentModule = true
            logger.debug("Found module section: ${moduleName}")
            return
        }

        // Check if we've moved to a different module
        if (line.matches(/^\s{2}\w+:\s*$/) && !line.contains(moduleName)) {
            inCurrentModule = false
            return
        }

        // Parse className if we're in current module
        if (inCurrentModule && line.contains('className:')) {
            def matcher = line =~ /className:\s*"([^"]+)"/
            if (matcher.find()) {
                def className = matcher.group(1)
                classNames.add(className)
                logger.debug("Found public class: ${className}")
            }
        }
    }

    logger.info("Found ${classNames.size()} public API classes for ${moduleName} in YAML")
    return classNames.isEmpty() ? null : classNames
}

/**
 * Parse ProGuard public.txt to determine which classes should be documented
 * @return List of source files to document, or null if ProGuard file not found
 */
def parseProguardPublicClasses() {
    def proguardFile = file("proguard/public.txt")

    if (!proguardFile.exists()) {
        logger.info("ProGuard public.txt not found for ${project.name}, documenting all public classes")
        return null
    }

    def publicSourceFiles = []

    proguardFile.eachLine { line ->
        def className = parseProguardClassName(line)
        if (!className) return

        // Resolve files (wildcard or concrete class)
        def files = className.contains('*') ?
            resolveWildcardPattern(className) :
            [resolveClassName(className)].findAll { it != null }

        // Add to result (avoid duplicates)
        files.each { f ->
            if (!publicSourceFiles.contains(f)) {
                publicSourceFiles.add(f)
            }
        }
    }

    logger.info("Found ${publicSourceFiles.size()} public classes in ${project.name} ProGuard file")
    return publicSourceFiles.isEmpty() ? null : publicSourceFiles
}

/**
 * Parse public API classes from YAML and resolve to source files
 * @return List of source files to document, or null if not found
 */
def parseYamlPublicClasses() {
    def classNames = parsePublicApiYaml()
    if (!classNames) return null

    def publicSourceFiles = []

    classNames.each { className ->
        // Resolve files (wildcard or concrete class)
        def files = className.contains('*') ?
            resolveWildcardPattern(className) :
            [resolveClassName(className)].findAll { it != null }

        // Add to result (avoid duplicates)
        files.each { f ->
            if (!publicSourceFiles.contains(f)) {
                publicSourceFiles.add(f)
            }
        }
    }

    logger.info("Resolved ${publicSourceFiles.size()} source files from YAML for ${project.name}")
    return publicSourceFiles.isEmpty() ? null : publicSourceFiles
}

// ============================================
// Shared Configuration Function
// ============================================

/**
 * Configure Dokka source set with filtering (YAML or ProGuard)
 * Can be reused for any Dokka format (GFM, HTML, Javadoc)
 * @param sourceSet Dokka source set to configure
 */
def configureDokkaSourceSet(sourceSet) {
    // Determine mode (check property again inside function scope)
    def useYamlMode = project.hasProperty('publicApiOnly') &&
            project.property('publicApiOnly').toString().toBoolean()

    // Choose source based on mode
    def publicClasses = useYamlMode ?
        parseYamlPublicClasses() :
        parseProguardPublicClasses()

    if (publicClasses != null && publicClasses.size() > 0) {
        // For mixed Java/Kotlin modules, use directory + suppressedFiles
        // For pure Java, use specific files
        def hasKotlinPlugin = project.plugins.hasPlugin('kotlin-android')

        if (hasKotlinPlugin) {
            // Use src/main/java directory and suppress non-public files
            sourceSet.sourceRoots.from("src/main/java")

            // Get all source files
            def allFiles = fileTree("src/main/java").matching {
                include '**/*.java'
                include '**/*.kt'
            }.files

            // Suppress files not in publicClasses list
            def filesToSuppress = allFiles - publicClasses
            sourceSet.suppressedFiles.from(filesToSuppress)

            logger.info("Documenting ${publicClasses.size()} classes from YAML/ProGuard for Kotlin module ${project.name}")
        } else {
            // Pure Java module - use specific files
            sourceSet.sourceRoots.from(publicClasses)
            logger.info("Documenting ${publicClasses.size()} classes from YAML/ProGuard for ${project.name}")
        }
    } else {
        // No public classes defined - skip documentation for this module
        logger.info("No public API classes defined for ${project.name} - skipping documentation")
    }

    // Skip deprecated methods/classes
    sourceSet.skipDeprecated.set(true)

    sourceSet.perPackageOption {
        matchingRegex.set(".*\\.internal.*")
        suppress.set(true)
    }
}

// ============================================
// GFM (Markdown) Configuration
// ============================================

tasks.dokkaGfm.configure {
    outputDirectory.set(file("${rootProject.ext.dokkaOutputDir}/${project.name}"))

    dokkaSourceSets {
        main {
            configureDokkaSourceSet(it)
        }
    }
}

// ============================================
// HTML Partial Configuration (for MultiModule)
// ============================================

tasks.dokkaHtmlPartial.configure {
    outputDirectory.set(file("${rootProject.ext.dokkaOutputDir}/${project.name}"))

    dokkaSourceSets {
        main {
            configureDokkaSourceSet(it)
        }
    }
}
